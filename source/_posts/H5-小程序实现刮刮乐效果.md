---
title: H5/小程序实现刮刮乐效果
date: 2017-11-21 09:31:03
tags: [h5, 小程序]
---

**预期效果**：遮罩层刮开部分显示底层图片，遮罩层被刮掉的面积到达一定百分比时去掉遮罩层。
**实现方案**：底层为图片或背景图，遮罩层使用canvas并根据设备类型绑定对应鼠标事件(mousedown/mousemove/mouseup)或触摸事件(touchstart/touchmove/touchend)。以鼠标事件为例：
当`mousedown`发生时，意味着刮开动作开始，用一个变量标识鼠标的按下状态，得到mousedown事件的坐标信息(x,y)，首先清除mousedown位置的像素，并将此时的(x,y)保存为(startX,stratY)。
当`mousemove`发生时，首先判断鼠标是否按下，若是，则说明此时是刮开动作移动中，清除掉上一步保存的(startX,stratY)和这个mousemove事件发生的坐标信息(x,y)之间的像素，并将(x,y)保存为新的(startX,stratY)，作为下次清除像素的起点。
当`mouseup`发生时，意味着刮开动作结束，修改鼠标的按下状态，并检查遮罩层的刮开面积，判断是否需要取消遮罩层。
关于设备判断及绑定事件的具体细节这里不做介绍，主要介绍一下在h5及小程序中针对其不同的canvas如何实现刮开区域的像素清除以及遮罩层刮开面积的检查方法。
<!--more-->
## **H5+canvas**
H5的canvasAPI中关于清除像素首先想到的就是`clearRect()`方法，`clearRect()`可以清除画布的矩形区域，但从用户体验的角度讲，显然圆形的剪裁更好一些，这时也就想到`clip()`方法，首先实现以鼠标位置为中心，适当长度为半径的圆形路径，然后使用`clip()`方法把这个路径作为*剪切区域*，再使用`clearRect()`清除像素。实现起来也不算复杂:
``` javascript
var canvas=document.getElementById("myCanvas")
var ctx=canvas.getContext("2d")

ctx.save()
ctx.beginPath()
ctx.arc(x,y,radius,0,2*Math.PI)
ctx.clip()
ctx.clearRect(0,0,canvas.width,canvas.height)
ctx.restore()
```
代码中的`save()`和`restore()`方法用来在构建剪切区域之前保存状态，完成剪切区域内的绘图之后进行状态读取，否则所有的绘图操作都会发生在剪切区域内。
上述方法已经可以很好的实现像素的清除了，但针对移动过程中的清除显然不是很好的方法，我们需要获取途径所有点的坐标来逐个清除，或者得到起始点和结束点所构成的四边形路径作为剪切区域来清除像素，四边形路径可以通过三角函数的方法得到，计算过程也不是很复杂，但这里介绍一个之前接触的很少的canvas属性——**`globalCompositeOperation`**，它规定了如何将一个新图像绘制到已有图像上。这个属性的默认值是`source-over`，也就是简单的叠加，效果如下图：
![source-over](http://km.midea.com/uploads/imgs/d1b17fbf3984.PNG)
这个属性还有一个值是`destination-out`，mdn上的解释是没有与新图像重叠部分的已有图像才会显示，效果如下图:
![destination-out](http://km.midea.com/uploads/imgs/7359d005af89.PNG)
这样的话我们就可以直接将需要清除的部分作为新图像绘制到绘图环境中，不需要clip()方法，也不需要对剪切区域的坐标进行计算，更减少了对绘图环境API的调用次数，提高了性能。
这样清除像素部分的代码也就相当于画图功能，直接设置绘图环境的line属性，然后通过lineTo进行绘制线条。移动过程的主要代码如下：
``` javascript
ctx.lineCap = "round"
ctx.lineJoin = "round"
ctx.lineWidth = radius*2
ctx.globalCompositeOperation = "destination-out"

ctx.save()
ctx.moveTo(startX,stratY)
ctx.lineTo(x,y)
ctx.stroke()
ctx.restore()

startX = x
startY = y

```
接下来介绍检查遮罩层刮开面积的方法，实现思路大概是使用`getImageData()`方法获取像素点的信息，查看其中透明像素所占的比例，若超过某一值(示例中为50%)，则设置遮罩层`display:none;`：
``` javascript
var imgData = this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight)
var transparent = 0

// 这里设置每隔30个像素检查一次，尽量减少循环计算所带来的负担
for (var x = 0; x < imgData.width; x += 30) {
    for (var y = 0; y < imgData.height; y += 30) {
        var i = (y * imgData.width + x) * 4;
        if (imgData.data[i + 3] > 0) {
            transparent++
        }
    }
}

if (transparent / (imgData.width * imgData.height / (30 * 30)) < 0.5) {
    canvas.className = 'hidden'
}
```
## **小程序+canvas**
小程序的canvas相对于h5来说就差得很远了，上述的主要方法包括清除像素时使用的globalCompositeOperation属性和检查清除面积时使用的getImageData()方法都不支持，甚至我们讨论的第一种使用clip()方法规定剪切区域来清除像素的方法在小程序中也无法实现，小程序的API中只有一个clearRect()可供我们使用。凹凸实验室前段时间推出的[小程序营销组件](https://github.com/o2team/wxapp-market)中包括了刮刮乐这一效果的实现，有体验过的同学也会发现效果不是很好，擦除笔迹不够连贯：

![alt](http://km.midea.com/uploads/imgs/f0a48f0dd32e.gif)
<font color=#767676 size="2">(注:此为开发者工具预览效果)</font>

看了一下实现代码发现其中touchStart和touchMove的实现方法是一样的，只是用clearRect()方法清除了事件坐标为中心的矩形绘图区域，这也就是当刮开动作稍快一些就会出现笔迹不连贯的原因。
我这里想到的优化办法是借鉴上述h5中的保存(startX,stratY)的方法，获取移动路径的起点和终点之间的所有点的坐标循环调用clearRect()方法，主要实现代码如下:
``` javascript
// 得到两点坐标差的比值
var ratio = (x - this.data.startX) / (y - this.data.stratY)
// 获取两点间直线上的所有点的方法针对移动方向有所不同
// 这里举例的前提为ratio>1&&this.data.startX < x
// 减少循环次数可以每隔多个像素获取一个点，如 i = i + 3
for (var i = this.data.startX; i <= x; i = i + 1) {
    var j = y - (x - i) / ratio
    ctx.clearRect(i - this.data.radius / 2, j - this.data.radius / 2, this.data.radius, this.data.radius)
    ctx.draw(true)
}
```

另外因为小程序中没有`getImageData()`方法，所以在检查刮开面积时，凹凸的做法是在刮开过程中分别保存笔迹坐标(x,y)的最大值和最小值，在touchEnd的时候判断其差值占宽和高的百分比，若都大于70%，则遮罩层消失。
虽然这种方法的弊端显而易见，但也是没有办法的办法，只能期待微信方面快些完善小程序啦~

